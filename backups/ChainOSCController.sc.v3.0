// File: Classes/ChainOSCController.sc
// Version: v0.3
/*
    ChainOSCController — v0.3
    MD 2025-09-05

    PURPOSE
    -------
    Entry point for performer OSC commands. Installs named OSCdef routes and
    forwards actions into the system (typically via ChainController and ChainManager).
    Hot‑reload safe (named defs + .free()) and test‑friendly (optional handler Functions).

    HOW THE SYSTEM FITS TOGETHER (first principles)
    -----------------------------------------------
      Performer (OSC)  ──>  ChainOSCController  ──>  ChainController  ──>  ChainManager  ──>  Ndef  ──>  FOH
                                      |                    |                  |
                                      |                    └── setNext(...)   ├── setSlot(i, \proc)
                                      |                                       ├── setChainSpec([...])
                                      └── routes: /chain/new, /chain/setNext, ├── play / stop
                                                         /chain/add, ...      └── free / freeImmediate

      • ChainManager: Owns one Ndef‑based audio chain with N slots. Self‑registers in a class registry.
                      Slot 0 is the source (\testsignal by default). Other slots are filters (\bypass default).
      • ChainController: Keeps <currentChain> and <nextChain>. switchNow() promotes next → current (stop old, play new).
      • ChainRegistry: Thin convenience for listing/freeing chains (reads ChainManager's class registry).
      • ProcessorLibrary: Catalog of processor “builders” (optional, not strictly required in this file).
      • GUI/Transition/Signals managers are orthogonal and not required for this controller to function.

    WHAT THIS CLASS DOES
    --------------------
      • Installs *named* OSCdef routes (per instance) and keeps their symbols in an IdentityDictionary.
      • Provides .free() to tear down only the installed defs (prevents zombie responders on hot‑reloads).
      • Minimal routes included by default:
          - /demo/ping                (sanity/logging)
          - /chain/setNext <name>     (notify controller or test handler)
          - /chain/switchNow          (notify controller or test handler)
        Additional routes (e.g. /chain/new, /chain/add, /chain/remove, /chain/setFrom) can be added later.
      • For tests, you may pass in handler Functions so no real ChainController/ChainManager is required.

    STYLE / SAFETY
    --------------
      • var‑first in every Function/closure.
      • No underscore‑prefixed method names (avoid PRIMITIVENAME parse errors).
      • No OSCFunc.removeAll (not available in all builds).
      • Posts are gated by a 'verbose' flag.

    CONSTRUCTOR & INJECTION
    -----------------------
      *new(controller, registry = nil, verbose = true, switchFunc = nil, setNextFunc = nil)
        • controller   : object with .switchNow / .setNext (optional)
        • registry     : optional reference (not used in this minimal version)
        • verbose      : gate console logs
        • switchFunc   : Function called on /chain/switchNow (test helper)
        • setNextFunc  : Function called with <name> on /chain/setNext (test helper)

    LIFECYCLE
    ---------
      .free() : frees only the OSCdef(s) installed by this instance.

    DEPENDENCIES
    ------------
      • SuperCollider core classes (OSCdef, IdentityDictionary, NetAddr).
      • Does NOT depend on server or Ndefs; audio‑free.

*/

ChainOSCController : Object {
    classvar < version = "v0.3";

    var verbose = true;
    var controller, registry;

    var defNames;         // IdentityDictionary: path(String) -> Symbol (OSCdef key)
    var id;               // per‑instance id for naming clarity
    var switchHandler;    // optional Function
    var setNextHandler;   // optional Function

    *new { |controller, registry = nil, verbose = true, switchFunc = nil, setNextFunc = nil|
        var instance;
        instance = super.new.init(controller, registry, verbose, switchFunc, setNextFunc);
        ^instance
    }

    init { |ctrl, reg, v, switchFunc, setNextFunc|
        var hash;
        controller     = ctrl;
        registry       = reg;
        verbose        = v;
        switchHandler  = switchFunc;
        setNextHandler = setNextFunc;

        defNames = IdentityDictionary.new;
        hash = this.identityHash;
        id = hash;

        if (verbose) {
            ("[ChainOSCController] init (version: %, id: %)".format(version, id)).postln;
        };

        this.installDefaultRoutes;
        ^this
    }

    // -------------------- ROUTES --------------------

    installDefaultRoutes {
        // Keep it minimal and testable; add more routes later as needed.

        // 1) /demo/ping  -> log
        this.prInstall("/demo/ping", { |msg, time, addr, recvPort|
            var args;
            args = if(msg.size > 1) { msg.copyRange(1, msg.size - 1) } { [] };
            this.prLog("RECV", "/demo/ping " ++ args.asString ++ " from " ++ addr.asString);
            this.prLog("DO", "pong");
            nil
        });

        // 2) /chain/setNext <name>  -> controller.setNext OR setNextHandler.(name)
        this.prInstall("/chain/setNext", { |msg, time, addr, recvPort|
            var name;
            name = msg[1].asSymbol;
            this.prLog("RECV", "/chain/setNext " ++ name.asString ++ " from " ++ addr.asString);

            if (setNextHandler.notNil) {
                setNextHandler.value(name);
            }{
                if (controller.notNil and: { controller.respondsTo(\setNext) }) {
                    // In a full system you’d look up: ChainManager.allInstances.at(name)
                    // To keep this file self‑contained for tests, we just call setNext with the name.
                    controller.setNext(name);
                }{
                    this.prLog("WARN", "no setNext handler or controller");
                };
            };
            nil
        });

        // 3) /chain/switchNow  -> controller.switchNow OR switchHandler.()
        this.prInstall("/chain/switchNow", { |msg, time, addr, recvPort|
            this.prLog("RECV", "/chain/switchNow from " ++ addr.asString);

            if (switchHandler.notNil) {
                switchHandler.value;
            }{
                if (controller.notNil and: { controller.respondsTo(\switchNow) }) {
                    controller.switchNow;
                }{
                    this.prLog("WARN", "no switchNow handler or controller");
                };
            };
            nil
        });

        ^this
    }

    // -------------------- LIFECYCLE --------------------

    free {
        var syms;
        syms = defNames.values.asArray;
        syms.do { |sym|
            var d;
            d = OSCdef(sym);
            if (d.notNil) { d.free };
        };
        defNames.clear;
        if (verbose) {
            ("[ChainOSCController] freed responders (id: %)".format(id)).postln;
        };
        ^this
    }

    // -------------------- HELPERS --------------------

    prInstall { |path, func|
        var p, defKey, action;
        p = path.asString;
        defKey = this.prMakeDefName(p);
        action = { |msg, time, addr, recvPort|
            var f;
            f = func;
            f.value(msg, time, addr, recvPort);
            nil
        };
        OSCdef(defKey, action, p);
        defNames[p] = defKey;
        if (verbose) {
            ("[ChainOSCController] installed % for %".format(defKey, p)).postln;
        };
        ^defKey
    }

    prMakeDefName { |path|
        var safe, str;
        safe = path.asString.collect { |ch|
            var code, rep;
            code = ch.ascii;
            if (code == $/.ascii) { rep = $_ } { rep = ch };
            rep
        }.join;
        str = "ChainOSCController_%_%_%".format(version, id, safe);
        ^str.asSymbol
    }

    prLog { |label, text|
        var doPost;
        doPost = verbose;
        if (doPost) {
            ("[ChainOSCController] " ++ label ++ ": " ++ text.asString).postln;
        };
        ^this
    }

    // Accessors for tests/inspection
    defNameForPath { |path|
        var key;
        key = path.asString;
        ^defNames[key]
    }

    getDefNames {
        ^defNames.copy
    }
}

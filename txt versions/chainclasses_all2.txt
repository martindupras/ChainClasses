// ChainController.sc
// v0.2
// MD 20250905: gate posts by 'verbose'; make status nil-safe.

ChainController : Object {
    classvar < version = "v0.2";
    var currentChain, nextChain, verbose = true;

    *new { |verbose = true|
        var instance;
        instance = super.new.init(verbose);
        ^instance
    }

    init { |v|
        verbose = v;
        if (verbose) {
            ("[ChainController] Initialized (% version)").format(version).postln;
        };
        ^this
    }

    setCurrent { |chainManager|
        currentChain = chainManager;
        if (verbose) {
            ("[ChainController] Current chain set to %".format(chainManager.getName)).postln;
        };
        ^this
    }

    setNext { |chainManager|
        nextChain = chainManager;
        if (verbose) {
            ("[ChainController] Next chain set to %".format(chainManager.getName)).postln;
        };
        ^this
    }

    switchNow {
        var hadNext, hadCurrent, newName;
        hadNext = nextChain.notNil;
        hadCurrent = currentChain.notNil;

        if (hadNext) {
            if (hadCurrent) { currentChain.stop };
            nextChain.play;
            currentChain = nextChain;
            nextChain = nil;
            newName = currentChain.getName;
            if (verbose) {
                ("[ChainController] Switched to chain %.".format(newName)).postln;
            };
        }{
            if (verbose) {
                "[ChainController] No next chain to switch to.".postln;
            };
        };
        ^this
    }

    status {
        var curName, nxtName;
        curName = if (currentChain.notNil) { currentChain.getName } { "None" };
        nxtName = if (nextChain.notNil) { nextChain.getName } { "None" };
        if (verbose) {
            ("[ChainController] Current: %, Next: %".format(curName, nxtName)).postln;
        };
        ^this
    }
}
/*  ChainManager.sc  — v2.3.1
    Manages an Ndef-based audio-effect chain with N slots (default 8).

    Key improvements vs. v2:
      - setSlot() keeps slotSpec coherent (unknown filters -> \bypass).
      - free(): disables crossfades and hard-clears Ndef (quiet teardown).
      - Helpers for deterministic edits/teardown:
          setSlotNoFade(index, symbol)
          setChainSpecNoFade(arrayOfSymbols)
          withNoFade({ ... })
          withNoLatency({ ... })
          withNoLatencyNoFade({ ... })
          withBundleNow({ ... })
          withNoLatencyNoFadeBundled({ ... })
          freeImmediate()

    Style: var-first in every Function/closure; lowercase descriptive names; accessors spaced.
*/

ChainManager : Object {
	classvar < version = "v2.3.1";
	var verbose = true;

	// ----- class state -----
	classvar < registry;      // IdentityDictionary[nameSymbol -> instance]
	classvar < nameCounter;   // Integer counter for auto-unique names

	// ----- instance state -----
	var < name;               // Symbol used as Ndef key
	var < numSlots;           // Integer >= 2
	var < slotSpec;           // Array of Symbols, e.g. [\testsignal, \bypass, ...]
	var < procDefs;           // IdentityDictionary[\symbol -> maker Function]
	var < isPlaying;          // Boolean
	var <> fadeTime = 0.1;    // Float; forwarded to Ndef(name).fadeTime

	*initClass {
		registry = IdentityDictionary.new;
		nameCounter = 0;
	}

	*uniqueName { |base = \chain|
		var candidate;
		candidate = base.asSymbol;
		while { registry.includesKey(candidate) } {
			nameCounter = nameCounter + 1;
			candidate = (base.asString ++ nameCounter.asString).asSymbol;
		};
		^candidate   // -> a unique Symbol for chain/Ndef name
	}

	*new { |name = nil, numSlots = 8|
		var instance;
		instance = super.new.init(name, numSlots);
		^instance    // -> new ChainManager instance
	}

	*allInstances {
		^registry.copy   // -> copy of { name -> instance } for discovery/GUI/bulk ops
	}

	// ChainManager.sc
	*freeAll {
		var instances = registry.values.asArray;   // snapshot
		instances.do { |inst| inst.freeImmediate }; // immediate clear, less chance of late /n_set
		^this
	}

	// ----- init -----
	init { |nm = nil, nSlots = 8, argVerbose = true|
		var baseName, finalName;
		verbose = argVerbose;
		if (verbose) { ("[ChainManager] Initialized (% version)").format(version).postln };

		baseName = if (nm.isNil) { "chain" } { nm.asString };
		if (registry.isNil) { registry = IdentityDictionary.new };
		finalName = this.class.uniqueName(baseName.asSymbol);

		numSlots  = nSlots.max(2);
		name      = finalName.asSymbol;
		isPlaying = false;

		//this.defineDefaultProcDefs; // no longer use procDefs in this file...
		this.adoptLibraryIfPresent;   // use those of ProcessorLibrary instead

		// Default: slot 0 is source; others bypass
		slotSpec = Array.fill(numSlots, { \bypass });
		slotSpec.put(0, \testsignal);

		this.buildChain;

		registry.put(name, this);
		^this
	}

	// pick up processor library:

	adoptLibraryIfPresent {
		var lib, keys;
		procDefs = IdentityDictionary.new;
		lib = ProcessorLibrary; // class itself
		if(lib.notNil and: { lib.respondsTo(\global) } and: { lib.global.notNil }) {
			// copy definitions from the global library instance
			keys = lib.global.list;
			keys.do({ arg k; procDefs.put(k, lib.global.get(k)) });
		} {
			this.defineDefaultProcDefs; // fallback to in-class defaults
		};
		^this
	}


	// ----- processor definitions (in-class fallback; should be using those of ProcessorLibrary) -----
	defineDefaultProcDefs {
		var hp, lp, trem, bypass, testsig;

		// High-pass (gentle)
		hp = {
			\filter -> { |in, freq = 300|
				var cut;
				cut = freq.clip(10, 20000);
				HPF.ar(in, cut)
			}
		};

		// Low-pass (gentle)
		lp = {
			\filter -> { |in, freq = 2000|
				var cut;
				cut = freq.clip(50, 20000);
				LPF.ar(in, cut)
			}
		};

		// Chopping tremolo
		trem = {
			\filter -> { |in, rate = 12, depth = 1.0, duty = 0.5|
				var chop, amount, dutyClamped;
				dutyClamped = duty.clip(0.05, 0.95);
				amount      = depth.clip(0, 1);
				chop        = LFPulse.kr(rate.max(0.1), 0, dutyClamped).lag(0.001);
				in * (chop * amount + (1 - amount))
			}
		};

		// Bypass
		bypass = { \filter -> { |in| in } };

		// Pulsed test signal (stereo), not obnoxious
		testsig = {
			{
				var trig, env, freqs, tone, pan, amp;
				trig  = Impulse.kr(2);
				env   = Decay2.kr(trig, 0.01, 0.15);
				freqs = [220, 330];
				tone  = SinOsc.ar(freqs, 0, 0.15).sum;
				amp   = env * 0.9;
				pan   = [-0.2, 0.2];
				[tone * amp, tone * amp] * (1 + pan)
			}
		};

		procDefs = IdentityDictionary.new;
		procDefs.put(\hp,         hp);
		procDefs.put(\lp,         lp);
		procDefs.put(\tremolo,    trem);
		procDefs.put(\bypass,     bypass);
		procDefs.put(\testsignal, testsig);
	}

	addProcessor { |keySymbol, makerFunc|
		var key;
		key = keySymbol.asSymbol;
		procDefs.put(key, makerFunc);
		^this
	}

	// ----- build chain from slotSpec -----
	buildChain {
		var index, symbol, maker;

		// 1) fade time
		Ndef(name).fadeTime = fadeTime;

		// 2) slot 0: source
		symbol = slotSpec[0];
		maker  = procDefs.at(symbol);
		if (maker.isNil) {
			maker = procDefs[\testsignal];
			slotSpec.put(0, \testsignal);
		};
		Ndef(name)[0] = maker.value;

		// 3) slots 1..end: filters
		index = 1;
		while { index < numSlots } {
			symbol = slotSpec[index];
			maker  = procDefs.at(symbol);
			if (maker.isNil) { maker = procDefs[\bypass] };
			Ndef(name)[index] = maker.value;
			index = index + 1;
		};
	}

	// ----- transport -----
	play {
		var wasPlaying;
		wasPlaying = isPlaying;
		if (wasPlaying.not) {
			Ndef(name).play;
			isPlaying = true;
		};
		^this
	}

	stop {
		var wasPlaying;
		wasPlaying = isPlaying;
		if (wasPlaying) {
			Ndef(name).stop;
			isPlaying = false;
		};
		^this
	}

	// Quiet free: force no-fade and hard-clear (no stop/release)
	free {
		var removedInstance, previousFadeTime;

		previousFadeTime = Ndef(name).fadeTime;
		Ndef(name).fadeTime = 0.0;
		Ndef(name).clear;
		Ndef(name).fadeTime = previousFadeTime;

		removedInstance = registry.removeAt(name);
		isPlaying = false;
		^removedInstance  // -> removed instance or nil
	}

	// Immediate, bundled free to avoid any delayed messages
	freeImmediate {
		var removedInstance, previousFadeTime, server;

		server = Ndef(name).server ? Server.default;
		previousFadeTime = Ndef(name).fadeTime;

		server.makeBundle(0.0, {
			Ndef(name).fadeTime = 0.0;
			Ndef(name).clear;
		});

		Ndef(name).fadeTime = previousFadeTime;

		removedInstance = registry.removeAt(name);
		isPlaying = false;
		^removedInstance  // -> removed instance or nil
	}

	// ----- slot edits -----
	setSlot { |index, symbol|
		var slotIndex, sym, maker;

		slotIndex = index.asInteger.clip(0, numSlots - 1);
		sym       = symbol.asSymbol;

		slotSpec.put(slotIndex, sym);
		maker = procDefs.at(sym);

		if (maker.isNil) {
			if (slotIndex == 0) {
				maker = procDefs[\testsignal];
				slotSpec.put(0, \testsignal);
			} {
				maker = procDefs[\bypass];
				slotSpec.put(slotIndex, \bypass);  // keep spec truthful for filters
			};
		};

		if (slotIndex == 0) {
			Ndef(name)[0] = maker.value;     // source
		} {
			Ndef(name)[slotIndex] = maker.value;   // filter
		};

		^this
	}

	setChainSpec { |arrayOfSymbols|
		var spec, symbol;

		spec = arrayOfSymbols.as(Array);

		if (spec.size < numSlots) {
			spec = spec ++ Array.fill(numSlots - spec.size, { \bypass });
		} {
			if (spec.size > numSlots) {
				spec = spec.copyRange(0, numSlots - 1);
			};
		};

		symbol = spec[0];
		if (procDefs.at(symbol).isNil or: { symbol != \testsignal }) {
			spec.put(0, \testsignal);
		};

		slotSpec = spec;
		this.buildChain;
		^this
	}

	// ----- helpers: no-fade / no-latency / bundling -----
	setSlotNoFade { |index, symbol|
		var previousFadeTime;
		previousFadeTime = Ndef(name).fadeTime;
		Ndef(name).fadeTime = 0.0;
		this.setSlot(index, symbol);
		Ndef(name).fadeTime = previousFadeTime;
		^this
	}

	setChainSpecNoFade { |arrayOfSymbols|
		var previousFadeTime;
		previousFadeTime = Ndef(name).fadeTime;
		Ndef(name).fadeTime = 0.0;
		this.setChainSpec(arrayOfSymbols);
		Ndef(name).fadeTime = previousFadeTime;
		^this
	}

	withNoFade { |function|
		var previousFadeTime;
		previousFadeTime = Ndef(name).fadeTime;
		Ndef(name).fadeTime = 0.0;
		function.value;
		Ndef(name).fadeTime = previousFadeTime;
		^this
	}

	withNoLatency { |function|
		var server, previousLatency;
		server = Ndef(name).server ? Server.default;
		previousLatency = server.latency;
		server.latency = 0.0;
		function.value;
		server.latency = previousLatency;
		^this
	}

	withNoLatencyNoFade { |function|
		var server, previousLatency, previousFadeTime;
		server = Ndef(name).server ? Server.default;
		previousLatency = server.latency;
		previousFadeTime = Ndef(name).fadeTime;
		server.latency = 0.0;
		Ndef(name).fadeTime = 0.0;
		function.value;
		Ndef(name).fadeTime = previousFadeTime;
		server.latency = previousLatency;
		^this
	}

	withBundleNow { |function|
		var server;
		server = Ndef(name).server ? Server.default;
		server.makeBundle(0.0, { function.value });
		^this
	}

	withNoLatencyNoFadeBundled { |function|
		var server, previousLatency, previousFadeTime;
		server = Ndef(name).server ? Server.default;
		previousLatency = server.latency;
		previousFadeTime = Ndef(name).fadeTime;

		server.latency = 0.0;
		Ndef(name).fadeTime = 0.0;

		server.makeBundle(0.0, {
			function.value;
		});

		Ndef(name).fadeTime = previousFadeTime;
		server.latency = previousLatency;
		^this
	}

	// ----- params, status, help -----
	set { |...paramPairs|
		var pairs;
		pairs = paramPairs;
		if (pairs.size.odd) {
			("ChainManager[%]: odd number of set() items ignored tail.").format(name).warn;
		};
		Ndef(name).set(*pairs);
		^this
	}

	status {
		var info;
		info = "ChainManager[%] slots: %".format(name, slotSpec);
		info.postln;
		^slotSpec.copy   // -> copy so callers can’t mutate internal state
	}

	help {
		var keys, lines;
		keys = procDefs.keys.asArray.sort;
		lines = [
			"ChainManager.help",
			"----------------------------------------",
			"Create:    c = ChainManager.new(\\myChain, 8);",
			"Play/Stop: c.play;  c.stop;",
			"Inspect:   c.status;  // prints and returns copy of slot spec",
			"Set slot:  c.setSlot(3, \\hp);  c.setSlot(4, \\lp);  c.setSlot(5, \\tremolo);",
			"Set chain: c.setChainSpec([\\testsignal, \\hp, \\tremolo, \\lp, \\bypass, \\bypass, \\bypass, \\bypass]);",
			"Params:    Ndef(c.getName).set(\\freq, 600, \\rate, 14, \\depth, 1.0);",
			"",
			"Helpers: setSlotNoFade, setChainSpecNoFade, withNoFade, withNoLatency,",
			"         withNoLatencyNoFade, withBundleNow, withNoLatencyNoFadeBundled, freeImmediate",
			"Available processors: " ++ keys.asString
		];
		lines.do { |line| line.postln };
		^this
	}

	// ----- simple accessors -----
	getName { ^name }
	getNumSlots { ^numSlots }
	getSpec { ^slotSpec.copy }
}
// Filename: ChainManagerDevTools.sc
//    taken out of the main class definition because they are not used right now.

// Purpose: Optional teardown helpers for advanced scheduling.
// Note: These are not required for normal live use.

+ ChainManager {
    editAndFreeBundled { |editFunction, delta = 0.05|
        var server, previousLatency, previousFadeTime;
        server = Ndef(name).server ? Server.default;
        previousLatency = server.latency;
        previousFadeTime = Ndef(name).fadeTime;
        server.latency = 0.0;
        Ndef(name).fadeTime = 0.0;
        server.makeBundle(delta, {
            editFunction.value;
            Ndef(name).clear;
        });
        Ndef(name).fadeTime = previousFadeTime;
        server.latency = previousLatency;
        registry.removeAt(name);
        isPlaying = false;
        ^this
    }

    endThenClear { |waitSeconds = nil|
        var server, previousLatency, previousFadeTime, waitTime;
        server = Ndef(name).server ? Server.default;
        previousLatency = server.latency;
        previousFadeTime = Ndef(name).fadeTime;
        waitTime = if(waitSeconds.isNil) { (previousLatency + 0.05).max(0.05) } { waitSeconds.max(0.01) };
        server.makeBundle(0.0, {
            Ndef(name).fadeTime = 0.0;
            Ndef(name).stop;
        });
        server.makeBundle(waitTime, { Ndef(name).clear; });
        Ndef(name).fadeTime = previousFadeTime;
        AppClock.sched(waitTime, {
            registry.removeAt(name);
            isPlaying = false;
            ^nil
        });
        ^this
    }

    editEndThenClearBundled { |editFunction, waitSeconds = nil|
        var server, previousLatency, previousFadeTime, waitTime;
        server = Ndef(name).server ? Server.default;
        previousLatency = server.latency;
        previousFadeTime = Ndef(name).fadeTime;
        waitTime = if(waitSeconds.isNil) { (previousLatency + 0.05).max(0.05) } { waitSeconds.max(0.01) };
        server.makeBundle(0.0, {
            Ndef(name).fadeTime = 0.0;
            editFunction.value;
            Ndef(name).stop;
        });
        server.makeBundle(waitTime, { Ndef(name).clear; });
        Ndef(name).fadeTime = previousFadeTime;
        AppClock.sched(waitTime, {
            registry.removeAt(name);
            isPlaying = false;
            ^nil
        });
        ^this
    }
}
// Filename: ChainOSCDispatcher.sc
// Version: v0.4.1
// Change notes:
// - v0.3.8: Refactor variable names to be descriptive; add instance/class `help` methods; add concise header.
// - v0.3.7: Correct OSC payload indexing (msg[1..]); toSymbol uses isKindOf(Symbol).
// - v0.3.6: Fix boolean precedence in size checks; keep read-only accessors; direct ivar assigns.
// - v0.3.5: Setter-free internal assigns; keep public accessors read-only (<).
// - v0.3.4: Always (re)bind OSCdef in installRoute to avoid stale handlers on recompile/rerun.
// - v0.3.3: Added edit routes; named OSCdefs; handler Functions; free(); Symbol normalization.
//
// Summary (≤30 lines):
// ChainOSCDispatcher is the SINGLE OSC entry point for a live-performance chain system.
// It installs named OSCdef routes (per instance), normalizes payloads, and forwards actions
// to either provided handler Functions or an optional ChainController instance.
// Key routes (payloads start at msg[1], since msg[0] is the address):
//   /demo/ping
//   /chain/setNext <name>
//   /chain/switchNow
//   /chain/new <name> [<slots>]
//   /chain/add <slot> <proc>       // 0-based slots; slot 0 = source
//   /chain/remove <slot>           // 0-based
//   /chain/setFrom <start> <list>  // 0-based; applies procs at start+i
// Notes:
//   - Names/procs are normalized to Symbols (\Name, \tremolo).
//   - Uses Dictionary+Symbol keys; named OSCdef per route; .free removes only installed defs.
//   - Tests can pass handler Functions; runtime can pass a real ChainController.
// See .help for usage and examples.

ChainOSCDispatcher {
    classvar <defaultVerbose;
    var <verbose;
    var <namePrefix;
    var <defNames;     // Dictionary: routeSymbol -> defNameSymbol (the OSCdef key)
    var <handlerMap;   // Dictionary: actionSymbol -> Function
    var <controller;   // optional ChainController

    *initClass {
        defaultVerbose = false;
    }

    *new { arg name, controller = nil, handlers = nil, verbose;
        var chosenVerbose;
        chosenVerbose = verbose;
        if(chosenVerbose.isNil) { chosenVerbose = defaultVerbose };
        ^super.new.init(name, controller, handlers, chosenVerbose)
    }

    // args renamed to avoid ivar shadowing; assign ivars directly (no setters)
    init { arg nameArg, controllerArg, handlersArg, verboseArg;
        var nameString;
        verbose = if(verboseArg.isNil) { defaultVerbose } { verboseArg };
        controller = controllerArg;
        defNames = Dictionary.new;
        handlerMap = Dictionary.new;

        nameString = nameArg;
        if(nameString.isNil) { nameString = "osc" };
        namePrefix = ("ChainOSCDispatcher%" ++ this.identityHash.asString ++ "%" ++ nameString.asString);

        if(handlersArg.notNil) { this.setHandlers(handlersArg) };

        this.installRoutes;
        ^this
    }

    // --- Public API ---

    setHandlers { arg handlers;
        var handlersDict;
        handlersDict = handlers;
        if(handlersDict.isKindOf(Dictionary).not) {
            this.log("setHandlers: non-Dictionary provided, ignoring");
            ^this
        };
        handlerMap = handlersDict.copy;
        ^this
    }

    defNameFor { arg routeSymbol;
        ^defNames[routeSymbol]
    }

    installedRoutes {
        ^defNames.keys
    }

    free {
        var removedDefNames;
        removedDefNames = List.new;
        // Dictionary.do yields values (defNameSymbol) then keys (routeSymbol)
        defNames.do { arg defNameSymbol, routeSymbol;
            var oscdefObject;
            oscdefObject = OSCdef(defNameSymbol);
            if(oscdefObject.notNil) {
                oscdefObject.free;
                removedDefNames.add(defNameSymbol);
            }
        };
        if(removedDefNames.size > 0) {
            this.log("free: removed % OSCdef(s)".format(removedDefNames.size));
        } {
            this.log("free: nothing to remove");
        };
        ^this
    }

    // Useful quick reference printed to post window
    help {
        var banner;
        banner = "ChainOSCDispatcher routes (payload indexing starts at msg[1]):\n"
        ++ "  /demo/ping\n"
        ++ "  /chain/setNext <name>\n"
        ++ "  /chain/switchNow\n"
        ++ "  /chain/new <name> [<slots>]\n"
        ++ "  /chain/add <slot> <proc>\n"
        ++ "  /chain/remove <slot>\n"
        ++ "  /chain/setFrom <start> <list...>\n\n"
        ++ "Notes:\n"
        ++ "  - 0-based slot indexing (slot 0 = source)\n"
        ++ "  - Names/procs normalized to Symbols (\"B\" -> \\B, \"tremolo\" -> \\tremolo)\n"
        ++ "  - Named OSCdefs per instance; .free only removes those\n\n"
        ++ "Example (no audio):\n"
        ++ "  h = Dictionary[ \\setNext -> { |name| (\"setNext:\" + name).postln } ];\n"
        ++ "  c = ChainOSCDispatcher.new(\"demo\", nil, h, true);\n"
        ++ "  n = NetAddr(\"127.0.0.1\", NetAddr.langPort);\n"
        ++ "  n.sendMsg(\"/chain/setNext\", \"B\");  // -> \\B\n"
        ++ "  c.free;";
        banner.postln;
        ^this
    }

    *help {
        var instance;
        instance = ChainOSCDispatcher.new("help", nil, nil, true);
        instance.help;
        instance.free;
        ^"See post window for usage."
    }

    // --- Private: route install ---

    installRoutes {
        this.installRoute('/demo/ping');
        this.installRoute('/chain/setNext');
        this.installRoute('/chain/switchNow');
        this.installRoute('/chain/new');
        this.installRoute('/chain/add');
        this.installRoute('/chain/remove');
        this.installRoute('/chain/setFrom');
        ^this
    }

    installRoute { arg routeString;
        var routeSymbol, defNameSymbol, handlerFunction;
        routeSymbol = routeString.asSymbol;
        defNameSymbol = this.makeDefName(routeSymbol);
        handlerFunction = this.makeHandlerFor(routeSymbol);

        // Always (re)bind so changes take effect after recompile/rerun.
        OSCdef(defNameSymbol, handlerFunction, routeString);
        defNames[routeSymbol] = defNameSymbol;

        this.log("installed/updated " ++ routeSymbol.asString ++ " -> " ++ defNameSymbol.asString);
        ^this
    }

    makeDefName { arg routeSymbol;
        var base, routeAsString, safeRoute;
        base = namePrefix;
        routeAsString = routeSymbol.asString;
        safeRoute = routeAsString.replace("/", "_");
        ^(base ++ "_" ++ safeRoute).asSymbol
    }

    // Build per-route OSCdef function
    makeHandlerFor { arg routeSymbol;
        var handlerFunc;
        handlerFunc = { arg msg, time, addr, recvPort;
            var routeSymbolLocal;
            routeSymbolLocal = routeSymbol;
            if(routeSymbolLocal == '/demo/ping'.asSymbol) {
                this.onPing(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/setNext'.asSymbol) {
                this.onSetNext(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/switchNow'.asSymbol) {
                this.onSwitchNow(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/new'.asSymbol) {
                this.onNew(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/add'.asSymbol) {
                this.onAdd(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/remove'.asSymbol) {
                this.onRemove(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/setFrom'.asSymbol) {
                this.onSetFrom(msg, time, addr, recvPort);
            } {
                this.log("handler: unknown route " ++ routeSymbolLocal.asString);
            }}}}}}};
        };
        ^handlerFunc
    }

    // --- Route handlers (var-first) ---

    onPing { arg msg, time, addr, recvPort;
        var callback;
        // msg[0] is address; payload starts at msg[1]
        this.log("/demo/ping " ++ msg.asString);
        callback = handlerMap[\ping];
        if(callback.notNil) { callback.(msg, time, addr, recvPort) };
    }

	onSetNext { arg msg, time, addr, recvPort;
    var nameAny, nameSymbol, callback, chain, all;
    nameAny = (msg.size > 1).if({ msg[1] }, { nil });
    nameSymbol = this.toSymbol(nameAny);
    if(nameSymbol.isNil) { this.log("setNext: missing name"); ^this };

    this.log("/chain/setNext " ++ nameSymbol.asString);

    // Prefer injected handler if provided
    callback = handlerMap[\setNext];
    if(callback.notNil) { callback.(nameSymbol); ^this };

    // Fallback: resolve by name and set on controller
    if(controller.notNil and: { controller.respondsTo(\setNext) }) {
        all = ChainManager.allInstances;
        chain = all.at(nameSymbol);
        if(chain.isNil) {
            this.log("setNext: no chain named " ++ nameSymbol.asString ++ " found");
            ^this;
        };
        controller.setNext(chain);
    };
    ^this
}


    onSwitchNow { arg msg, time, addr, recvPort;
        var callback;
        this.log("/chain/switchNow");
        callback = handlerMap[\switchNow];
        if(callback.notNil) { callback.() } {
            if(controller.notNil and: { controller.respondsTo(\switchNow) }) { controller.switchNow };
        };
        ^this
    }

    onNew { arg msg, time, addr, recvPort;
        var nameAny, nameSymbol, slots, callback;
        nameAny = (msg.size > 1).if({ msg[1] }, { nil });
        nameSymbol = this.toSymbol(nameAny);
        slots = (msg.size > 2).if({ msg[2].asInteger }, { nil });
        if(nameSymbol.isNil) { this.log("new: missing name"); ^this };
        this.log("/chain/new " ++ nameSymbol.asString ++ (slots.notNil.if({ " " ++ slots.asString }, { "" })));
        callback = handlerMap[\new];
        if(callback.notNil) { callback.(nameSymbol, slots) };
        ^this
    }

    onAdd { arg msg, time, addr, recvPort;
        var slotAny, procAny, slotIndex, procSymbol, callback;
        slotAny = (msg.size > 1).if({ msg[1] }, { nil });
        procAny = (msg.size > 2).if({ msg[2] }, { nil });
        if(slotAny.isNil or: { procAny.isNil }) { this.log("add: requires <slot> <proc>"); ^this };
        slotIndex = slotAny.asInteger; // 0-based
        procSymbol = this.toSymbol(procAny);
        this.log("/chain/add slot:" ++ slotIndex.asString ++ " proc:" ++ procSymbol.asString);
        callback = handlerMap[\add];
        if(callback.notNil) { callback.(slotIndex, procSymbol) };
        ^this
    }

    onRemove { arg msg, time, addr, recvPort;
        var slotAny, slotIndex, callback;
        slotAny = (msg.size > 1).if({ msg[1] }, { nil });
        if(slotAny.isNil) { this.log("remove: requires <slot>"); ^this };
        slotIndex = slotAny.asInteger; // 0-based
        this.log("/chain/remove slot:" ++ slotIndex.asString);
        callback = handlerMap[\remove];
        if(callback.notNil) { callback.(slotIndex) };
        ^this
    }

    onSetFrom { arg msg, time, addr, recvPort;
        var startAny, startIndex, restArgs, procSymbols, callback;
        // Need at least address + start + one proc => size >= 3
        if(msg.size < 3) { this.log("setFrom: requires <start> <list...>"); ^this };
        startAny = msg[1];
        startIndex = startAny.asInteger;
        restArgs = msg.copyRange(2, msg.size - 1);
        procSymbols = restArgs.collect({ arg item; this.toSymbol(item) });
        this.log("/chain/setFrom start:" ++ startIndex.asString ++ " procs:" ++ procSymbols.asString);
        callback = handlerMap[\setFrom];
        if(callback.notNil) { callback.(startIndex, procSymbols) };
        ^this
    }

    // --- Utilities ---

    toSymbol { arg x;
        var symbolValue;
        if(x.isNil) { ^nil };
        if(x.isKindOf(Symbol)) { ^x };
        symbolValue = x.asString.asSymbol;
        ^symbolValue
    }

    log { arg line;
        var lineString;
        if(verbose.not) { ^this };
        lineString = "[ChainOSCDispatcher] " ++ line.asString;
        lineString.postln;
        ^this
    }
}
// ChainRegistry.sc
// v0.1
// MD 20250905:1230

ChainRegistry : Object {
	classvar < version = "v0.1";
	var verbose = true;

	*new { |verbose = true|
		var instance;
		instance = super.new.init(verbose);
		^instance
	}

	init { |v|
		//var keys;
		verbose = v;
		if (verbose) {
			("[ChainRegistry] Initialized (% version)").format(version).postln;
		};
		^this
	}

	// ChainRegistry.sc
	listAll {
		var keys;
		keys = ChainManager.allInstances.keys.asArray.sort;   // <- deterministic, sorted
		("[ChainRegistry] Chains: %".format(keys)).postln;
		^keys
	}


	describeAll {
		var dict;
		dict = ChainManager.allInstances;
		dict.keysValuesDo { |key, chain|
			chain.status;
		};
		^this
	}

	freeAll {
		ChainManager.freeAll;
		"[ChainRegistry] All chains freed.".postln;
		^this
	}
}
/*  Filename: ChainStatusUI.sc
    Version:  v0.3.2
    Purpose:  Read-only GUI showing Current and Next chains with colored slot boxes.

    Key fixes:
      - Use List instead of Array for box/label collections (Array.add returns a new Array; List.add mutates).
      - Re-entrancy guard uses a normal ivar (no accessor, no underscore): isPaintingLock.
      - Defaults set in init rather than in var declarations.

    Notes:
      - Boxes per slot: source (slot 0) = blue; active effect = green; bypass = light grey; next (queued) = orange.
      - Auto-resizes up to maxSlots by observing current/next chain sizes.
      - Call .setCurrent(chainOrNil) and .setNext(chainOrNil). UI refresh is AppClock-safe.
      - Optional debug prints: pass debug:true to *new or use .setDebug(true).
*/

ChainStatusUI : Object {
    var <window;
    var <currentPanel, <nextPanel;
    var <currentBoxes, <nextBoxes;       // List
    var <currentLabels, <nextLabels;     // List
    var <titleCurrent, <titleNext, <legendText;
    var <pollRoutine, <pollHz;
    var <currentChainRef, <nextChainRef;
    var <maxSlots;
    var <monoFont;
    var <debug;                // set via setDebug
    var isPaintingLock;        // re-entrancy guard (no accessor, no underscore)

    *new { arg title = "Chain Status v6", pollRate = 4, debug = false;
        ^super.new.init(title, pollRate, debug)
    }

    init { arg title, pollRate, debug = false;
        var w, lineH, pad, fontSize, f1, f2;

        // defaults
        isPaintingLock = false;
        this.setDebug(debug);

        pollHz = pollRate;
        currentChainRef = nil;
        nextChainRef    = nil;
        maxSlots        = 8;

        fontSize = 12;
        f1 = Font("Monaco", fontSize);
        f2 = Font("Menlo",  fontSize);
        monoFont = f1;
        if(monoFont.isNil) { monoFont = f2 };
        if(monoFont.isNil) { monoFont = Font.default };

        lineH = 22;
        pad   = 10;

        w = Window(title, Rect(100, 100, 720, 360)).alwaysOnTop_(true);
        window = w;

        titleCurrent = StaticText(w, Rect(pad, pad, 320, lineH))
            .string_("Current")
            .font_(Font.default.size_(14))
            .background_(Color(0.85, 1.0, 0.85));

        titleNext = StaticText(w, Rect(360, pad, 320, lineH))
            .string_("Next")
            .font_(Font.default.size_(14))
            .background_(Color(1.0, 0.98, 0.85));

        currentPanel = CompositeView(w, Rect(pad,  pad + lineH + 6, 320, 260)).background_(Color.white);
        nextPanel    = CompositeView(w, Rect(360, pad + lineH + 6, 320, 260)).background_(Color.white);

        legendText = StaticText(w, Rect(pad, 330, 680, 18))
            .string_("Legend: source=blue | active=green | bypass=grey | queued(next)=orange")
            .font_(Font.default.size_(11));

        // Lists (mutate in place with .add)
        currentBoxes  = List.new;
        nextBoxes     = List.new;
        currentLabels = List.new;
        nextLabels    = List.new;

        // Build initial views to maxSlots; no chain yet
        this.buildBoxes(currentPanel, currentBoxes, currentLabels, maxSlots);
        this.buildBoxes(nextPanel,    nextBoxes,    nextLabels,    maxSlots);

        w.onClose_({
            var r;
            r = pollRoutine;
            if(r.notNil) { r.stop; pollRoutine = nil };
        });

        this.startPolling;
        { this.refresh }.defer;
        w.front;
        ^this
    }

    // --- Diagnostics & control ---

    setDebug { arg flag = true;
        debug = (flag == true);
        if(debug) {
            this.log("debug enabled (id:" ++ this.identityHash.asString ++ ")");
        };
        ^this
    }

    describe {
        var curN, nxtN;
        curN = if(currentChainRef.notNil) { currentChainRef.getName } { "nil" };
        nxtN = if(nextChainRef.notNil)    { nextChainRef.getName    } { "nil" };
        (
            "[ChainStatusUI] id:% maxSlots:% curBoxes:% nextBoxes:% curLabels:% nextLabels:% cur:% next:%"
        ).format(
            this.identityHash, maxSlots,
            currentBoxes.size, nextBoxes.size,
            currentLabels.size, nextLabels.size,
            curN, nxtN
        ).postln;
        ^this
    }

    validateViews {
        var ok;
        ok = true;
        if(window.isNil) {
            "WARNING: ChainStatusUI.validateViews: window is nil (closed?)".warn;
            ok = false;
        };
        if(currentBoxes.size != maxSlots) {
            ("WARNING: ChainStatusUI: currentBoxes.size % vs maxSlots %")
            .format(currentBoxes.size, maxSlots).warn;
            ok = false;
        };
        if(nextBoxes.size != maxSlots) {
            ("WARNING: ChainStatusUI: nextBoxes.size % vs maxSlots %")
            .format(nextBoxes.size, maxSlots).warn;
            ok = false;
        };
        if(currentLabels.size != maxSlots or: { nextLabels.size != maxSlots }) {
            ("WARNING: ChainStatusUI: label array sizes mismatch (cur % next % max %)")
            .format(currentLabels.size, nextLabels.size, maxSlots).warn;
            ok = false;
        };
        ^ok
    }

    log { arg line;
        if(debug) { ("[ChainStatusUI] " ++ line.asString).postln; };
        ^this
    }

    // --- View construction ---

    buildBoxes { arg panel, boxArray, labelArray, slots;
        var s, i, cols, spacing, boxW, boxH, x0, y0, row, col, bx, by, box, lab, fontSmall;

        s = slots.asInteger;
        if(s.isNil or: { s < 1 }) { s = 1 };
        if(s > 16) { s = 16 };

        if(debug) { this.log(("buildBoxes(slots:%) panel:%").format(s, panel.bounds)); };

        cols = s.min(8).max(1);
        spacing = 6;
        boxW = ((panel.bounds.width - (cols - 1) * spacing).max(160) / cols).clip(28, 80);
        boxH = 44;
        x0 = 0; y0 = 0;
        fontSmall = monoFont.size_(11);

        // Clear existing child views and collections
        boxArray.do({ arg v; v.remove });
        labelArray.do({ arg v; v.remove });
        boxArray.clear; labelArray.clear;

        i = 0;
        while({ i < s }, {
            row = (i / 8).floor;
            col = i % 8;
            bx = x0 + col * (boxW + spacing);
            by = y0 + row * (boxH + spacing);

            box = CompositeView(panel, Rect(bx, by, boxW, boxH)).background_(Color(0.95, 0.95, 0.95));
            lab = StaticText(box, Rect(4, 4, boxW - 8, boxH - 8))
                .string_("-")
                .font_(fontSmall);

            boxArray.add(box);
            labelArray.add(lab);
            i = i + 1;
        });

        if(debug) {
            this.log(("built arrays -> boxes:% labels:% (this side)")
                .format(boxArray.size, labelArray.size));
        };
        ^this
    }

    // --- Public API (runtime hooks) ---

    setCurrent { arg chainOrNil;
        var ch;
        ch = chainOrNil;
        currentChainRef = ch;
        { this.refresh }.defer;
        ^this
    }

    setNext { arg chainOrNil;
        var ch;
        ch = chainOrNil;
        nextChainRef = ch;
        { this.refresh }.defer;
        ^this
    }

    setMaxSlots { arg slots;
        var s;
        s = slots;
        if(debug) { this.log(("setMaxSlots request:% (prev max:%)").format(s, maxSlots)); };

        if(s.isNil) { s = maxSlots };
        if(s < 1)   { s = 1 };
        if(s > 16)  { s = 16 };
        maxSlots = s;

        this.buildBoxes(currentPanel, currentBoxes, currentLabels, maxSlots);
        this.buildBoxes(nextPanel,    nextBoxes,    nextLabels,    maxSlots);

        if(debug) {
            this.log(("setMaxSlots done -> max:% curBoxes:% nextBoxes:%")
                .format(maxSlots, currentBoxes.size, nextBoxes.size));
        };

        { this.refresh }.defer;
        ^this
    }

    front {
        var w;
        w = window;
        if(w.notNil) { w.front };
        ^this
    }

    free {
        var w, r;
        r = pollRoutine;
        if(r.notNil) { r.stop; pollRoutine = nil };
        w = window;
        if(w.notNil) { w.close };
        window = nil;
        ^this
    }

    // --- Poller ---

    startPolling {
        var hz, wait, r;

        if(pollRoutine.notNil) { pollRoutine.stop; pollRoutine = nil; };

        hz = pollHz;
        if(hz.isNil) { hz = 4 };
        if(hz <= 0)  { ^this }; // disabled

        wait = (1.0 / hz).max(0.05);

        r = Routine({
            var localWait;
            localWait = wait;
            while({ window.notNil }, {
                this.refresh;
                localWait.wait;
            });
        });

        pollRoutine = r.play(AppClock);
        ^this
    }

    // --- Paint helpers ---

    slotColorFor { arg symbol, isCurrent, index;
        var sym, isByp, isSrc;
        sym = symbol.asSymbol;
        isByp = (sym == \bypass);
        isSrc = (index == 0);

        if(isSrc)                        { ^Color(0.60, 0.80, 1.00) }; // blue: source
        if(isByp and: { isCurrent })     { ^Color(0.90, 0.90, 0.90) }; // light grey (current)
        if(isByp and: { isCurrent.not }) { ^Color(0.93, 0.93, 0.93) }; // slightly lighter grey (next)
        if(isCurrent)                    { ^Color(0.70, 1.00, 0.70) }; // green: active
        ^Color(1.00, 0.78, 0.40)                                      // orange: queued (next)
    }

    shortName { arg symbol;
        var s;
        s = symbol.asString;
        if(s.size > 8) { ^(s.copyRange(0, 7) ++ "…") };
        ^s
    }

    normalizeToSymbol { arg item, fallback = \bypass;
        var sym;
        if(item.isNil)            { ^fallback };
        if(item.isKindOf(Symbol)) { ^item     };
        if(item.isKindOf(String)) { ^item.asSymbol };
        if(item.respondsTo(\key)) {  // Associations
            sym = item.key; if(sym.isKindOf(Symbol)) { ^sym };
        };
        if(item.isKindOf(Dictionary)) {
            sym = item[\name]; if(sym.notNil) { ^sym.asSymbol };
            ^fallback;
        };
        ^fallback
    }

    // --- Main paint ---

    refresh {
        var c, n, cSpec, nSpec, cSlots, nSlots, needed;
        var i, sym, box, lab, color, cname, nname;

        if(window.isNil) { ^this }; // closed

        // Re-entrancy guard
        if(isPaintingLock) { ^this };
        isPaintingLock = true;

        if(debug) { this.validateViews; };

        c = currentChainRef;
        n = nextChainRef;

        cSlots = 0; if(c.notNil) { cSlots = c.getNumSlots };
        nSlots = 0; if(n.notNil) { nSlots = n.getNumSlots };

        needed = cSlots.max(nSlots);
        if(needed == 0) { needed = maxSlots };

        // Resize and bail; deferred refresh will repaint freshly built views.
        if(needed != maxSlots) {
            if(debug) { this.log(("resize: needed:% (cur max:%) — rebuilding").format(needed, maxSlots)); };
            this.setMaxSlots(needed);
            isPaintingLock = false;
            ^this;
        };

        cname = "Current: -"; if(c.notNil) { cname = "Current: " ++ c.getName.asString };
        titleCurrent.string_(cname);

        nname = "Next: -"; if(n.notNil) { nname = "Next: " ++ n.getName.asString };
        titleNext.string_(nname);

        cSpec = Array.fill(maxSlots, { \bypass });
        nSpec = Array.fill(maxSlots, { \bypass });
        if(c.notNil) { cSpec = c.getSpec };
        if(n.notNil) { nSpec = n.getSpec };

        if(debug) {
            this.log(("paint with maxSlots:%  cur:%  next:%  (curName:% nextName:%)")
                .format(
                    maxSlots, cSpec, nSpec,
                    (c.notNil).if({ c.getName }, { "nil" }),
                    (n.notNil).if({ n.getName }, { "nil" })
                ));
        };

        i = 0;
        while({ i < maxSlots }, {
            // Current
            sym  = (i < cSpec.size).if({ this.normalizeToSymbol(cSpec[i]) }, { \bypass });
            box  = currentBoxes[i];
            lab  = currentLabels[i];
            color = this.slotColorFor(sym, true, i);
            if(box.notNil) { box.background_(color) };
            if(lab.notNil) { lab.string_(this.shortName(sym)) };

            // Next
            sym  = (i < nSpec.size).if({ this.normalizeToSymbol(nSpec[i]) }, { \bypass });
            box  = nextBoxes[i];
            lab  = nextLabels[i];
            color = this.slotColorFor(sym, false, i);
            if(box.notNil) { box.background_(color) };
            if(lab.notNil) { lab.string_(this.shortName(sym)) };

            i = i + 1;
        });

        isPaintingLock = false;
        ^this
    }
}
// ChainTransitionManager.sc
// MD 20250909-0811

// v0.2 — ensure switchOnBeat schedules into the future (no immediate trigger at exact downbeat)
// Also uses numeric rounding in logs (sclang doesn't support printf %.2f/%.3f)

ChainTransitionManager : Object {
    classvar < version = "v0.1c";
    var verbose = true;
    var controller;

    *new { |controller, verbose = true|
        ^super.new.init(controller, verbose)
    }

    init { |ctrl, v|
        var now;
        controller = ctrl;
        verbose = v;
        if (verbose) {
            ("[ChainTransitionManager] Initialized (% version)").format(version).postln;
        };
        now = SystemClock.seconds.round(0.001);
        ("[ChainTransitionManager] Ready at %".format(now)).postln;
        ^this
    }

    // Schedule after 'seconds' on SystemClock
    switchIn { |seconds|
        var delay = seconds.max(0.01);
        ("[ChainTransitionManager] Scheduled switch in % seconds."
            .format(delay.round(0.01))).postln;

        SystemClock.sched(delay, {
            controller.switchNow;
            nil;  // never ^return from inside scheduled functions
        });

        ^this
    }

    // Schedule on a TempoClock at the next whole beat, unless we're exactly on it:
    // In that case, advance to the following beat. Then add (beatsAhead-1).
    switchOnBeat { |beatClock, beatsAhead = 1|
        var nowBeat, nextWhole, targetBeat, ahead;
        nowBeat   = beatClock.beats;          // current absolute beat (Float)
        nextWhole = nowBeat.ceil;             // next integer beat OR same if already integer
        if (nextWhole == nowBeat) {           // exactly on a downbeat -> force future
            nextWhole = nowBeat + 1;
        };
        ahead     = (beatsAhead - 1).max(0);
        targetBeat = nextWhole + ahead;

        ("[ChainTransitionManager] Scheduled switch on beat % (tempoClock)."
            .format(targetBeat)).postln;

        beatClock.sched(targetBeat, {
            controller.switchNow;
            nil;
        });

        ^this
    }
}// ProcessorLibrary.sc
// v0.1
// MD 20250905:1345

ProcessorLibrary : Object {
    classvar < version = "v0.1";
	classvar < global;
    var verbose = true;
    var processors;

    *new { |verbose = true|
        var instance;
        instance = super.new.init(verbose);
        ^instance
    }

	*initClass {
    global = ProcessorLibrary.new(true);
	}

    init { |v|
        verbose = v;
        processors = IdentityDictionary.new;
        if (verbose) {
            ("[ProcessorLibrary] Initialized (% version)").format(version).postln;
        };
        this.defineDefaults;
        ^this
    }

    defineDefaults {
        this.add(\hp, {
            \filter -> { |in, freq = 300|
                var cut;
                cut = freq.clip(10, 20000);
                HPF.ar(in, cut)
            }
        });

        this.add(\lp, {
            \filter -> { |in, freq = 2000|
                var cut;
                cut = freq.clip(50, 20000);
                LPF.ar(in, cut)
            }
        });

        this.add(\tremolo, {
            \filter -> { |in, rate = 12, depth = 1.0, duty = 0.5|
                var chop, amount, dutyClamped;
                dutyClamped = duty.clip(0.05, 0.95);
                amount = depth.clip(0, 1);
                chop = LFPulse.kr(rate.max(0.1), 0, dutyClamped).lag(0.001);
                in * (chop * amount + (1 - amount))
            }
        });

        this.add(\bypass, { \filter -> { |in| in } });

        this.add(\testsignal, {
            {
                var trig, env, freqs, tone, pan, amp;
                trig = Impulse.kr(2);
                env = Decay2.kr(trig, 0.01, 0.15);
                freqs = [220, 330];
                tone = SinOsc.ar(freqs, 0, 0.15).sum;
                amp = env * 0.9;
                pan = [-0.2, 0.2];
                [tone * amp, tone * amp] * (1 + pan)
            }
        });
    }

    add { |key, func|
        processors.put(key.asSymbol, func);
        if (verbose) {
            ("[ProcessorLibrary] Added processor: %".format(key)).postln;
        };
        ^this
    }

    get { |key|
        ^processors.at(key.asSymbol);
    }

    list {
        ^processors.keys.asArray.sort;
    }

    describe {
        ("[ProcessorLibrary] Available processors: %".format(this.list)).postln;
        ^this
    }
}

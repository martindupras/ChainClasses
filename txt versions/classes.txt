// ChainController.sc
// v0.2
// MD 20250905: gate posts by 'verbose'; make status nil-safe.

ChainController : Object {
    classvar < version = "v0.2";
    var currentChain, nextChain, verbose = true;

    *new { |verbose = true|
        var instance;
        instance = super.new.init(verbose);
        ^instance
    }

    init { |v|
        verbose = v;
        if (verbose) {
            ("[ChainController] Initialized (% version)").format(version).postln;
        };
        ^this
    }

    setCurrent { |chainManager|
        currentChain = chainManager;
        if (verbose) {
            ("[ChainController] Current chain set to %".format(chainManager.getName)).postln;
        };
        ^this
    }

    setNext { |chainManager|
        nextChain = chainManager;
        if (verbose) {
            ("[ChainController] Next chain set to %".format(chainManager.getName)).postln;
        };
        ^this
    }

    switchNow {
        var hadNext, hadCurrent, newName;
        hadNext = nextChain.notNil;
        hadCurrent = currentChain.notNil;

        if (hadNext) {
            if (hadCurrent) { currentChain.stop };
            nextChain.play;
            currentChain = nextChain;
            nextChain = nil;
            newName = currentChain.getName;
            if (verbose) {
                ("[ChainController] Switched to chain %.".format(newName)).postln;
            };
        }{
            if (verbose) {
                "[ChainController] No next chain to switch to.".postln;
            };
        };
        ^this
    }

    status {
        var curName, nxtName;
        curName = if (currentChain.notNil) { currentChain.getName } { "None" };
        nxtName = if (nextChain.notNil) { nextChain.getName } { "None" };
        if (verbose) {
            ("[ChainController] Current: %, Next: %".format(curName, nxtName)).postln;
        };
        ^this
    }
}
// Filename: ChainOSCController.sc
// Version: v0.3.8
// Change notes:
// - v0.3.8: Refactor variable names to be descriptive; add instance/class `help` methods; add concise header.
// - v0.3.7: Correct OSC payload indexing (msg[1..]); toSymbol uses isKindOf(Symbol).
// - v0.3.6: Fix boolean precedence in size checks; keep read-only accessors; direct ivar assigns.
// - v0.3.5: Setter-free internal assigns; keep public accessors read-only (<).
// - v0.3.4: Always (re)bind OSCdef in installRoute to avoid stale handlers on recompile/rerun.
// - v0.3.3: Added edit routes; named OSCdefs; handler Functions; free(); Symbol normalization.
//
// Summary (≤30 lines):
// ChainOSCController is the SINGLE OSC entry point for a live-performance chain system.
// It installs named OSCdef routes (per instance), normalizes payloads, and forwards actions
// to either provided handler Functions or an optional ChainController instance.
// Key routes (payloads start at msg[1], since msg[0] is the address):
//   /demo/ping
//   /chain/setNext <name>
//   /chain/switchNow
//   /chain/new <name> [<slots>]
//   /chain/add <slot> <proc>       // 0-based slots; slot 0 = source
//   /chain/remove <slot>           // 0-based
//   /chain/setFrom <start> <list>  // 0-based; applies procs at start+i
// Notes:
//   - Names/procs are normalized to Symbols (\Name, \tremolo).
//   - Uses Dictionary+Symbol keys; named OSCdef per route; .free removes only installed defs.
//   - Tests can pass handler Functions; runtime can pass a real ChainController.
// See .help for usage and examples.

ChainOSCController {
    classvar <defaultVerbose;
    var <verbose;
    var <namePrefix;
    var <defNames;     // Dictionary: routeSymbol -> defNameSymbol (the OSCdef key)
    var <handlerMap;   // Dictionary: actionSymbol -> Function
    var <controller;   // optional ChainController

    *initClass {
        defaultVerbose = false;
    }

    *new { arg name, controller = nil, handlers = nil, verbose;
        var chosenVerbose;
        chosenVerbose = verbose;
        if(chosenVerbose.isNil) { chosenVerbose = defaultVerbose };
        ^super.new.init(name, controller, handlers, chosenVerbose)
    }

    // args renamed to avoid ivar shadowing; assign ivars directly (no setters)
    init { arg nameArg, controllerArg, handlersArg, verboseArg;
        var nameString;
        verbose = if(verboseArg.isNil) { defaultVerbose } { verboseArg };
        controller = controllerArg;
        defNames = Dictionary.new;
        handlerMap = Dictionary.new;

        nameString = nameArg;
        if(nameString.isNil) { nameString = "osc" };
        namePrefix = ("ChainOSCController%" ++ this.identityHash.asString ++ "%" ++ nameString.asString);

        if(handlersArg.notNil) { this.setHandlers(handlersArg) };

        this.installRoutes;
        ^this
    }

    // --- Public API ---

    setHandlers { arg handlers;
        var handlersDict;
        handlersDict = handlers;
        if(handlersDict.isKindOf(Dictionary).not) {
            this.log("setHandlers: non-Dictionary provided, ignoring");
            ^this
        };
        handlerMap = handlersDict.copy;
        ^this
    }

    defNameFor { arg routeSymbol;
        ^defNames[routeSymbol]
    }

    installedRoutes {
        ^defNames.keys
    }

    free {
        var removedDefNames;
        removedDefNames = List.new;
        // Dictionary.do yields values (defNameSymbol) then keys (routeSymbol)
        defNames.do { arg defNameSymbol, routeSymbol;
            var oscdefObject;
            oscdefObject = OSCdef(defNameSymbol);
            if(oscdefObject.notNil) {
                oscdefObject.free;
                removedDefNames.add(defNameSymbol);
            }
        };
        if(removedDefNames.size > 0) {
            this.log("free: removed % OSCdef(s)".format(removedDefNames.size));
        } {
            this.log("free: nothing to remove");
        };
        ^this
    }

    // Useful quick reference printed to post window
    help {
        var banner;
        banner = "ChainOSCController routes (payload indexing starts at msg[1]):\n"
        ++ "  /demo/ping\n"
        ++ "  /chain/setNext <name>\n"
        ++ "  /chain/switchNow\n"
        ++ "  /chain/new <name> [<slots>]\n"
        ++ "  /chain/add <slot> <proc>\n"
        ++ "  /chain/remove <slot>\n"
        ++ "  /chain/setFrom <start> <list...>\n\n"
        ++ "Notes:\n"
        ++ "  - 0-based slot indexing (slot 0 = source)\n"
        ++ "  - Names/procs normalized to Symbols (\"B\" -> \\B, \"tremolo\" -> \\tremolo)\n"
        ++ "  - Named OSCdefs per instance; .free only removes those\n\n"
        ++ "Example (no audio):\n"
        ++ "  h = Dictionary[ \\setNext -> { |name| (\"setNext:\" + name).postln } ];\n"
        ++ "  c = ChainOSCController.new(\"demo\", nil, h, true);\n"
        ++ "  n = NetAddr(\"127.0.0.1\", NetAddr.langPort);\n"
        ++ "  n.sendMsg(\"/chain/setNext\", \"B\");  // -> \\B\n"
        ++ "  c.free;";
        banner.postln;
        ^this
    }

    *help {
        var instance;
        instance = ChainOSCController.new("help", nil, nil, true);
        instance.help;
        instance.free;
        ^"See post window for usage."
    }

    // --- Private: route install ---

    installRoutes {
        this.installRoute('/demo/ping');
        this.installRoute('/chain/setNext');
        this.installRoute('/chain/switchNow');
        this.installRoute('/chain/new');
        this.installRoute('/chain/add');
        this.installRoute('/chain/remove');
        this.installRoute('/chain/setFrom');
        ^this
    }

    installRoute { arg routeString;
        var routeSymbol, defNameSymbol, handlerFunction;
        routeSymbol = routeString.asSymbol;
        defNameSymbol = this.makeDefName(routeSymbol);
        handlerFunction = this.makeHandlerFor(routeSymbol);

        // Always (re)bind so changes take effect after recompile/rerun.
        OSCdef(defNameSymbol, handlerFunction, routeString);
        defNames[routeSymbol] = defNameSymbol;

        this.log("installed/updated " ++ routeSymbol.asString ++ " -> " ++ defNameSymbol.asString);
        ^this
    }

    makeDefName { arg routeSymbol;
        var base, routeAsString, safeRoute;
        base = namePrefix;
        routeAsString = routeSymbol.asString;
        safeRoute = routeAsString.replace("/", "_");
        ^(base ++ "_" ++ safeRoute).asSymbol
    }

    // Build per-route OSCdef function
    makeHandlerFor { arg routeSymbol;
        var handlerFunc;
        handlerFunc = { arg msg, time, addr, recvPort;
            var routeSymbolLocal;
            routeSymbolLocal = routeSymbol;
            if(routeSymbolLocal == '/demo/ping'.asSymbol) {
                this.onPing(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/setNext'.asSymbol) {
                this.onSetNext(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/switchNow'.asSymbol) {
                this.onSwitchNow(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/new'.asSymbol) {
                this.onNew(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/add'.asSymbol) {
                this.onAdd(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/remove'.asSymbol) {
                this.onRemove(msg, time, addr, recvPort);
            } {
            if(routeSymbolLocal == '/chain/setFrom'.asSymbol) {
                this.onSetFrom(msg, time, addr, recvPort);
            } {
                this.log("handler: unknown route " ++ routeSymbolLocal.asString);
            }}}}}}};
        };
        ^handlerFunc
    }

    // --- Route handlers (var-first) ---

    onPing { arg msg, time, addr, recvPort;
        var callback;
        // msg[0] is address; payload starts at msg[1]
        this.log("/demo/ping " ++ msg.asString);
        callback = handlerMap[\ping];
        if(callback.notNil) { callback.(msg, time, addr, recvPort) };
    }

    onSetNext { arg msg, time, addr, recvPort;
        var nameAny, nameSymbol, callback;
        nameAny = (msg.size > 1).if({ msg[1] }, { nil });
        nameSymbol = this.toSymbol(nameAny);
        if(nameSymbol.isNil) { this.log("setNext: missing name"); ^this };
        this.log("/chain/setNext " ++ nameSymbol.asString);
        callback = handlerMap[\setNext];
        if(callback.notNil) { callback.(nameSymbol) } {
            if(controller.notNil and: { controller.respondsTo(\setNext) }) { controller.setNext(nameSymbol) };
        };
        ^this
    }

    onSwitchNow { arg msg, time, addr, recvPort;
        var callback;
        this.log("/chain/switchNow");
        callback = handlerMap[\switchNow];
        if(callback.notNil) { callback.() } {
            if(controller.notNil and: { controller.respondsTo(\switchNow) }) { controller.switchNow };
        };
        ^this
    }

    onNew { arg msg, time, addr, recvPort;
        var nameAny, nameSymbol, slots, callback;
        nameAny = (msg.size > 1).if({ msg[1] }, { nil });
        nameSymbol = this.toSymbol(nameAny);
        slots = (msg.size > 2).if({ msg[2].asInteger }, { nil });
        if(nameSymbol.isNil) { this.log("new: missing name"); ^this };
        this.log("/chain/new " ++ nameSymbol.asString ++ (slots.notNil.if({ " " ++ slots.asString }, { "" })));
        callback = handlerMap[\new];
        if(callback.notNil) { callback.(nameSymbol, slots) };
        ^this
    }

    onAdd { arg msg, time, addr, recvPort;
        var slotAny, procAny, slotIndex, procSymbol, callback;
        slotAny = (msg.size > 1).if({ msg[1] }, { nil });
        procAny = (msg.size > 2).if({ msg[2] }, { nil });
        if(slotAny.isNil or: { procAny.isNil }) { this.log("add: requires <slot> <proc>"); ^this };
        slotIndex = slotAny.asInteger; // 0-based
        procSymbol = this.toSymbol(procAny);
        this.log("/chain/add slot:" ++ slotIndex.asString ++ " proc:" ++ procSymbol.asString);
        callback = handlerMap[\add];
        if(callback.notNil) { callback.(slotIndex, procSymbol) };
        ^this
    }

    onRemove { arg msg, time, addr, recvPort;
        var slotAny, slotIndex, callback;
        slotAny = (msg.size > 1).if({ msg[1] }, { nil });
        if(slotAny.isNil) { this.log("remove: requires <slot>"); ^this };
        slotIndex = slotAny.asInteger; // 0-based
        this.log("/chain/remove slot:" ++ slotIndex.asString);
        callback = handlerMap[\remove];
        if(callback.notNil) { callback.(slotIndex) };
        ^this
    }

    onSetFrom { arg msg, time, addr, recvPort;
        var startAny, startIndex, restArgs, procSymbols, callback;
        // Need at least address + start + one proc => size >= 3
        if(msg.size < 3) { this.log("setFrom: requires <start> <list...>"); ^this };
        startAny = msg[1];
        startIndex = startAny.asInteger;
        restArgs = msg.copyRange(2, msg.size - 1);
        procSymbols = restArgs.collect({ arg item; this.toSymbol(item) });
        this.log("/chain/setFrom start:" ++ startIndex.asString ++ " procs:" ++ procSymbols.asString);
        callback = handlerMap[\setFrom];
        if(callback.notNil) { callback.(startIndex, procSymbols) };
        ^this
    }

    // --- Utilities ---

    toSymbol { arg x;
        var symbolValue;
        if(x.isNil) { ^nil };
        if(x.isKindOf(Symbol)) { ^x };
        symbolValue = x.asString.asSymbol;
        ^symbolValue
    }

    log { arg line;
        var lineString;
        if(verbose.not) { ^this };
        lineString = "[ChainOSCController] " ++ line.asString;
        lineString.postln;
        ^this
    }
}
// ChainRegistry.sc
// v0.1
// MD 20250905:1230

ChainRegistry : Object {
	classvar < version = "v0.1";
	var verbose = true;

	*new { |verbose = true|
		var instance;
		instance = super.new.init(verbose);
		^instance
	}

	init { |v|
		var keys;
		verbose = v;
		if (verbose) {
			("[ChainRegistry] Initialized (% version)").format(version).postln;
		};
		^this
	}

	// ChainRegistry.sc
	listAll {
		var keys;
		keys = ChainManager.allInstances.keys.asArray.sort;   // <- deterministic, sorted
		("[ChainRegistry] Chains: %".format(keys)).postln;
		^keys
	}


	describeAll {
		var dict;
		dict = ChainManager.allInstances;
		dict.keysValuesDo { |key, chain|
			chain.status;
		};
		^this
	}

	freeAll {
		ChainManager.freeAll;
		"[ChainRegistry] All chains freed.".postln;
		^this
	}
}
// Filename: ChainStarter_v0_1_7.scd
// Version: v0.1.7
// Purpose: Boots audio, installs OSC routes, edits a "next" chain, switches live, and shows a status GUI.
// Notes:
// - Uses local ~nextChainRef (Option A) to track the ChainManager instance we edit as "next".
// - Slot indexing is 0-based (slot 0 = \testsignal). Names/procs are Symbols (normalized by ChainOSCController).
// - Requires: ChainManager v2.2, ChainController v0.2, ChainOSCController v0.3.8+, ChainStatusUI v0.1.2.
// - UI calls from OSC handlers are deferred to AppClock to satisfy Qt's threading rules.
// - NEW: switchNow auto-promotes local ~nextChainRef if controller has no next set (more forgiving live flow).

(
// ---------------------------
// Config & re-run hygiene
// ---------------------------
var priorOsc;
priorOsc = ~osc;
if(priorOsc.notNil) { priorOsc.free; };

if(~starterVerbose.isNil) { ~starterVerbose = true; };

~post = { arg line;
    var s;
    s = line;
    if(~starterVerbose) { ("[ChainStarter] " ++ s.asString).postln; };
};

// Local state for "next" chain and lookup by name
~nextChainRef = nil;
~byName = IdentityDictionary.new;

// Array-based local OSC sender (no varargs syntax)
~send = { arg addr, argsArray;
    var n, args;
    n = NetAddr("127.0.0.1", NetAddr.langPort);
    args = argsArray;
    if(args.isNil) { args = Array.new; };
    args = args.as(Array);
    n.sendMsg(addr, *args);
    ~post.("sent " ++ addr.asString ++ " " ++ args.asString);
};

// Convenience helpers
~forceSwitchFromLocal = {
    var ch;
    ch = ~nextChainRef;
    if(ch.notNil) {
        ~controller.setNext(ch);
        ~controller.switchNow;
        if(~statusUI.notNil) { { ~statusUI.setCurrent(ch); ~statusUI.setNext(nil) }.defer; };
        ~nextChainRef = nil;
        ~controller.status;
    } {
        ~post.("forceSwitch: ~nextChainRef is nil; create or set a next chain first.");
    };
};

~playNdef = { arg nameSym;
    var nm;
    nm = nameSym.asSymbol;
    Ndef(nm).play;
    ~post.("Ndef(" ++ nm.asString ++ ").play issued (direct).");
};

// ---------------------------
// Boot audio (runtime demo)
// ---------------------------
~post.("Booting audio server...");
s.waitForBoot({
    var handlers, resolveByName, installTime;

    ~post.("Server booted. sampleRate:" ++ s.sampleRate.asString ++ " latency:" ++ s.latency.asString);

    // Optional: show available processors if ProcessorLibrary exists (safe via tryPerform)
    if(ProcessorLibrary.notNil) {
        ProcessorLibrary.tryPerform(\global);
        ProcessorLibrary.tryPerform(\describe);
    };

    // Resolve a ChainManager by name Symbol (local cache, then global registry snapshot)
    resolveByName = { arg nameSym;
        var inst, all;
        inst = ~byName[nameSym];
        if(inst.isNil) {
            all = ChainManager.allInstances;
            inst = all.at(nameSym);
        };
        ^inst;
    };

    // Runtime handlers used by ChainOSCController
    handlers = Dictionary[
        \new -> { arg nameSym, slotsInt;
            var chain, finalName, slots;
            slots = slotsInt;
            if(slots.isNil) { slots = 8; };
            chain = ChainManager.new(nameSym, slots);
            finalName = chain.getName;
            ~byName[finalName] = chain;
            ~nextChainRef = chain;
            ~post.("new: created " ++ finalName.asString ++ " slots:" ++ chain.getNumSlots.asString);
            chain.status;
            // UI: defer to AppClock
            if(~statusUI.notNil) { { ~statusUI.setNext(chain) }.defer; };
        },
        \setNext -> { arg nameSym;
            var chain;
            chain = resolveByName.(nameSym);
            if(chain.isNil) {
                ~post.("setNext: no chain named " ++ nameSym.asString ++ " found");
                ^nil;
            };
            ~controller.setNext(chain);
            ~nextChainRef = chain;
            ~post.("setNext: next=" ++ chain.getName.asString);
            // UI: defer to AppClock
            if(~statusUI.notNil) { { ~statusUI.setNext(chain) }.defer; };
        },
        \add -> { arg slotIndex, procSym;
            var chain;
            chain = ~nextChainRef;
            if(chain.isNil) {
                ~post.("add: no nextChainRef set yet; call /chain/new or /chain/setNext first");
                ^nil;
            };
            chain.setSlot(slotIndex, procSym);
            ~post.("add: slot:" ++ slotIndex.asString ++ " proc:" ++ procSym.asString ++ " on " ++ chain.getName.asString);
            chain.status;
            // UI: defer to AppClock
            if(~statusUI.notNil) { { ~statusUI.setNext(chain) }.defer; };
        },
        \remove -> { arg slotIndex;
            var chain;
            chain = ~nextChainRef;
            if(chain.isNil) {
                ~post.("remove: no nextChainRef set yet; call /chain/new or /chain/setNext first");
                ^nil;
            };
            chain.setSlot(slotIndex, \bypass);
            ~post.("remove: slot:" ++ slotIndex.asString ++ " -> \\bypass on " ++ chain.getName.asString);
            chain.status;
            // UI: defer to AppClock
            if(~statusUI.notNil) { { ~statusUI.setNext(chain) }.defer; };
        },
        \setFrom -> { arg startIndex, procSyms;
            var chain;
            chain = ~nextChainRef;
            if(chain.isNil) {
                ~post.("setFrom: no nextChainRef set yet; call /chain/new or /chain/setNext first");
                ^nil;
            };
            procSyms.do({ arg p, i;
                var idx;
                idx = startIndex + i;
                chain.setSlot(idx, p);
            });
            ~post.("setFrom: start:" ++ startIndex.asString ++ " procs:" ++ procSyms.asString ++ " on " ++ chain.getName.asString);
            chain.status;
            // UI: defer to AppClock
            if(~statusUI.notNil) { { ~statusUI.setNext(chain) }.defer; };
        },

/*        \switchNow -> {
            var becomingCurrent, autoUsedLocal;
            becomingCurrent = ~nextChainRef;
            autoUsedLocal = false;

            if(becomingCurrent.notNil) {
                ~controller.setNext(becomingCurrent);
                autoUsedLocal = true;
                ~post.("switchNow: auto-promoted local ~nextChainRef (" ++ becomingCurrent.getName.asString ++ ")");
            };

            ~controller.switchNow;

            if(becomingCurrent.notNil and: { ~statusUI.notNil }) {
                { ~statusUI.setCurrent(becomingCurrent) }.defer;
            };

            if(autoUsedLocal) {
                ~nextChainRef = nil;
                if(~statusUI.notNil) { { ~statusUI.setNext(nil) }.defer; };
            };

            ~post.("switchNow: performed");
            ~controller.status;
        }*/
		\switchNow -> {
    var becomingCurrent, autoUsedLocal, curForUI;

    becomingCurrent = ~nextChainRef;
    autoUsedLocal = false;

    if(becomingCurrent.notNil) {
        ~controller.setNext(becomingCurrent);
        autoUsedLocal = true;
        ~post.("switchNow: auto-promoted local ~nextChainRef (" ++ becomingCurrent.getName.asString ++ ")");
    };

    ~controller.switchNow;

    // --- Robust UI update: find what is actually playing if we didn't have a local pointer
    curForUI = becomingCurrent;
    if(curForUI.isNil) {
        var all;
        all = ChainManager.allInstances;  // IdentityDictionary name -> instance
        all.valuesDo({ arg ch;
            if(ch.notNil and: { ch.isPlaying }) { curForUI = ch };
        });
        if(curForUI.notNil) {
            ~post.("switchNow: detected current playing chain -> " ++ curForUI.getName.asString);
        } {
            ~post.("switchNow: no playing chain detected.");
        };
    };

    if(curForUI.notNil and: { ~statusUI.notNil }) {
        { ~statusUI.setCurrent(curForUI) }.defer;
    };

    if(autoUsedLocal) {
        ~nextChainRef = nil;
        if(~statusUI.notNil) { { ~statusUI.setNext(nil) }.defer };
    };

    ~post.("switchNow: performed");
    ~controller.status;
}

    ];

    // Create controller (verbose true so you can see status)
    ~controller = ChainController.new(true);
    ~controller.status;

    // Install OSC surface (verbose true)
    ~osc = ChainOSCController.new("starter", ~controller, handlers, true);
    ~post.("OSC routes installed: " ++ ~osc.installedRoutes.asString);

    // Bring up the status UI (create once)
    if(~statusUI.isNil) {
        ~statusUI = ChainStatusUI.new("Chain Status v6", 4);
    };

    // Diagnostics helper
    ~diagnose = {
        var routes, all, nextName;
        routes = ~osc.installedRoutes;
        all = ChainManager.allInstances;
        nextName = "None";
        if(~nextChainRef.notNil) { nextName = ~nextChainRef.getName; };
        ~post.("Routes: " ++ routes.asString);
        ChainRegistry.new(true).listAll;
        ~controller.status;
        ("[ChainStarter] Local nextChainRef: " ++ nextName.asString).postln;
        if(~nextChainRef.notNil) { ~nextChainRef.status; };
        ^this;
    };

    // Scripted demo (optional; adjust the /chain/setNext name to the actual printed name if suffixed)
    ~demo = {
        fork({
            var n;
            n = NetAddr("127.0.0.1", NetAddr.langPort);

            ~post.("Demo: creating \\Edit with 6 slots");
            ~send.("/chain/new", ["Edit", 6]);
            0.25.wait;

            ~post.("Demo: add \\tremolo at slot 1, \\hp at slot 2");
            ~send.("/chain/add", [1, "tremolo"]);
            0.15.wait;
            ~send.("/chain/add", [2, "hp"]);
            0.15.wait;

            ~post.("Demo: switch now (auto-uses local next if needed)");
            ~send.("/chain/switchNow");
            0.3.wait;

            ~diagnose.();
        }, SystemClock);
    };

    // Cleanup helper
    ~cleanup = {
        if(~osc.notNil) { ~osc.free; ~osc = nil; };
        ChainRegistry.new(true).freeAll;
        ~byName = IdentityDictionary.new;
        ~nextChainRef = nil;
        if(~statusUI.notNil) { { ~statusUI.setCurrent(nil); ~statusUI.setNext(nil) }.defer; };
        ~post.("Cleanup complete.");
        ^this;
    };

    installTime = Date.localtime;
    ~post.("Starter ready at " ++ installTime.asString);
});
)
// Filename: ChainStatusUI.sc
// Version: v0.2.1
// Purpose: Read-only GUI showing Current and Next chains with colored slot boxes.
// Notes:
// - Boxes per slot: source (slot 0) = blue; active effect = green; bypass = light grey; next (queued) = orange.
// - Auto-resizes up to maxSlots by observing current/next chain sizes.
// - Call .setCurrent(chainOrNil) and .setNext(chainOrNil). Calls schedule refresh on AppClock.
// - Conservative syntax: no '??', no '?', var-first in all Functions.

ChainStatusUI {
    var <window;
    var <currentPanel, <nextPanel;
    var <currentBoxes, <nextBoxes;
    var <currentLabels, <nextLabels;
    var <titleCurrent, <titleNext, <legendText;
    var <pollRoutine, <pollHz;
    var <currentChainRef, <nextChainRef;
    var <maxSlots;
    var <monoFont;

    *new { arg title = "Chain Status v6", pollRate = 4;
        var ui;
        ui = super.new.init(title, pollRate);
        ^ui
    }

    init { arg title, pollRate;
        var w, lineH, pad, fontSize, f1, f2;
        pollHz = pollRate;
        currentChainRef = nil;
        nextChainRef = nil;
        maxSlots = 8;

        fontSize = 12;
        f1 = Font("Monaco", fontSize);
        f2 = Font("Menlo", fontSize);
        monoFont = f1;
        if(monoFont.isNil) { monoFont = f2 };
        if(monoFont.isNil) { monoFont = Font.default };

        lineH = 22;
        pad = 10;

        w = Window(title, Rect(100, 100, 720, 360)).alwaysOnTop_(true);
        window = w;

        titleCurrent = StaticText(w, Rect(pad, pad, 320, lineH))
            .string_("Current")
            .font_(Font.default.size_(14))
            .background_(Color(0.85, 1.0, 0.85));

        titleNext = StaticText(w, Rect(360, pad, 320, lineH))
            .string_("Next")
            .font_(Font.default.size_(14))
            .background_(Color(1.0, 0.98, 0.85));

        currentPanel = CompositeView(w, Rect(pad, pad + lineH + 6, 320, 260)).background_(Color.white);
        nextPanel    = CompositeView(w, Rect(360, pad + lineH + 6, 320, 260)).background_(Color.white);

        legendText = StaticText(w, Rect(pad, 330, 680, 18))
            .string_("Legend: source=blue | active=green | bypass=grey | queued(next)=orange")
            .font_(Font.default.size_(11));

        currentBoxes = Array.new;
        nextBoxes = Array.new;
        currentLabels = Array.new;
        nextLabels = Array.new;

        this.buildBoxes(currentPanel, currentBoxes, currentLabels, maxSlots);
        this.buildBoxes(nextPanel,    nextBoxes,    nextLabels,    maxSlots);

        w.onClose_({
            var r;
            r = pollRoutine;
            if(r.notNil) { r.stop; pollRoutine = nil };
        });

        this.startPolling;
        { this.refresh }.defer;
        w.front;
        ^this
    }

    buildBoxes { arg panel, boxArray, labelArray, slots;
        var i, cols, spacing, boxW, boxH, x0, y0, row, col, bx, by, box, lab, fontSmall;
        cols = slots.min(8);
        spacing = 6;
        boxW = ((panel.bounds.width - (cols - 1) * spacing).max(160) / cols).clip(28, 80);
        boxH = 44;
        x0 = 0;
        y0 = 0;
        fontSmall = monoFont.size_(11);

        boxArray.do({ arg v; v.remove });
        labelArray.do({ arg v; v.remove });
        boxArray.clear; labelArray.clear;

        i = 0;
        while({ i < slots }, {
            row = (i / 8).floor;
            col = i % 8;
            bx = x0 + col * (boxW + spacing);
            by = y0 + row * (boxH + spacing);

            box = CompositeView(panel, Rect(bx, by, boxW, boxH)).background_(Color(0.95, 0.95, 0.95));
            lab = StaticText(box, Rect(4, 4, boxW - 8, boxH - 8))
                .string_("-")
                .font_(fontSmall);

            boxArray.add(box);
            labelArray.add(lab);

            i = i + 1;
        });
    }

    setCurrent { arg chainOrNil;
        var ch;
        ch = chainOrNil;
        currentChainRef = ch;
        { this.refresh }.defer;
        ^this
    }

    setNext { arg chainOrNil;
        var ch;
        ch = chainOrNil;
        nextChainRef = ch;
        { this.refresh }.defer;
        ^this
    }

    setMaxSlots { arg slots;
        var s;
        s = slots;
        if(s.isNil) { s = maxSlots };
        if(s < 1) { s = 1 };
        if(s > 16) { s = 16 };
        maxSlots = s;

        this.buildBoxes(currentPanel, currentBoxes, currentLabels, maxSlots);
        this.buildBoxes(nextPanel,    nextBoxes,    nextLabels,    maxSlots);
        { this.refresh }.defer;
        ^this
    }

    front {
        var w;
        w = window;
        if(w.notNil) { w.front };
        ^this
    }

    free {
        var w, r;
        r = pollRoutine;
        if(r.notNil) { r.stop; pollRoutine = nil };
        w = window;
        if(w.notNil) { w.close };
        window = nil;
        ^this
    }

    startPolling {
        var hz, wait, r;
        hz = pollHz;
        if(hz.isNil) { hz = 4 };
        wait = (1.0 / hz).max(0.05);
        r = Routine({
            var localWait;
            localWait = wait;
            while({ window.notNil }, {
                this.refresh;
                localWait.wait;
            });
        });
        pollRoutine = r.play(AppClock);
        ^this
    }

    slotColorFor { arg symbol, isCurrent, index;
        var sym, isByp, isSrc;
        sym = symbol.asSymbol;
        isByp = (sym == \bypass);
        isSrc = (index == 0);
        if(isSrc) { ^Color(0.60, 0.80, 1.00) };
        if(isByp and: { isCurrent }) { ^Color(0.90, 0.90, 0.90) };
        if(isByp and: { isCurrent.not }) { ^Color(0.93, 0.93, 0.93) };
        if(isCurrent) { ^Color(0.70, 1.00, 0.70) };
        ^Color(1.00, 0.78, 0.40)
    }

    shortName { arg symbol;
        var s;
        s = symbol.asString;
        if(s.size > 8) { ^(s.copyRange(0, 7) ++ "…") };
        ^s
    }

    refresh {
        var c, n, cSpec, nSpec, cSlots, nSlots, needed;
        var i, sym, box, lab, color, cname, nname;

        c = currentChainRef;
        n = nextChainRef;

        cSlots = 0;
        nSlots = 0;
        if(c.notNil) { cSlots = c.getNumSlots };
        if(n.notNil) { nSlots = n.getNumSlots };

        needed = cSlots.max(nSlots);
        if(needed == 0) { needed = maxSlots };
        if(needed != maxSlots) { this.setMaxSlots(needed) };

        cname = "Current: -";
        if(c.notNil) { cname = "Current: " ++ c.getName.asString };
        titleCurrent.string_(cname);

        nname = "Next: -";
        if(n.notNil) { nname = "Next: " ++ n.getName.asString };
        titleNext.string_(nname);

        cSpec = Array.fill(maxSlots, { \bypass });
        nSpec = Array.fill(maxSlots, { \bypass });
        if(c.notNil) { cSpec = c.getSpec };
        if(n.notNil) { nSpec = n.getSpec };

        i = 0;
        while({ i < maxSlots }, {
            sym = (i < cSpec.size).if({ cSpec[i] }, { \bypass });
            box = currentBoxes[i];
            lab = currentLabels[i];
            color = this.slotColorFor(sym, true, i);
            if(box.notNil) { box.background_(color) };
            if(lab.notNil) { lab.string_(this.shortName(sym)) };

            sym = (i < nSpec.size).if({ nSpec[i] }, { \bypass });
            box = nextBoxes[i];
            lab = nextLabels[i];
            color = this.slotColorFor(sym, false, i);
            if(box.notNil) { box.background_(color) };
            if(lab.notNil) { lab.string_(this.shortName(sym)) };

            i = i + 1;
        });

        ^this
    }
}
// ProcessorLibrary.sc
// v0.1
// MD 20250905:1345

ProcessorLibrary : Object {
    classvar < version = "v0.1";
	classvar < global;
    var verbose = true;
    var processors;

    *new { |verbose = true|
        var instance;
        instance = super.new.init(verbose);
        ^instance
    }

	*initClass {
    global = ProcessorLibrary.new(true);
	}

    init { |v|
        verbose = v;
        processors = IdentityDictionary.new;
        if (verbose) {
            ("[ProcessorLibrary] Initialized (% version)").format(version).postln;
        };
        this.defineDefaults;
        ^this
    }

    defineDefaults {
        this.add(\hp, {
            \filter -> { |in, freq = 300|
                var cut;
                cut = freq.clip(10, 20000);
                HPF.ar(in, cut)
            }
        });

        this.add(\lp, {
            \filter -> { |in, freq = 2000|
                var cut;
                cut = freq.clip(50, 20000);
                LPF.ar(in, cut)
            }
        });

        this.add(\tremolo, {
            \filter -> { |in, rate = 12, depth = 1.0, duty = 0.5|
                var chop, amount, dutyClamped;
                dutyClamped = duty.clip(0.05, 0.95);
                amount = depth.clip(0, 1);
                chop = LFPulse.kr(rate.max(0.1), 0, dutyClamped).lag(0.001);
                in * (chop * amount + (1 - amount))
            }
        });

        this.add(\bypass, { \filter -> { |in| in } });

        this.add(\testsignal, {
            {
                var trig, env, freqs, tone, pan, amp;
                trig = Impulse.kr(2);
                env = Decay2.kr(trig, 0.01, 0.15);
                freqs = [220, 330];
                tone = SinOsc.ar(freqs, 0, 0.15).sum;
                amp = env * 0.9;
                pan = [-0.2, 0.2];
                [tone * amp, tone * amp] * (1 + pan)
            }
        });
    }

    add { |key, func|
        processors.put(key.asSymbol, func);
        if (verbose) {
            ("[ProcessorLibrary] Added processor: %".format(key)).postln;
        };
        ^this
    }

    get { |key|
        ^processors.at(key.asSymbol);
    }

    list {
        ^processors.keys.asArray.sort;
    }

    describe {
        ("[ProcessorLibrary] Available processors: %".format(this.list)).postln;
        ^this
    }
}
